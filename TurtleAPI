--
-- TurtleAPI
--


assert(os.loadAPI("LogAPI"), "LogAPI failed to load")

log = LogAPI.logger
log.usecolor = false
log.level = "info"
log.outfile = "turtle.log"
log.outfileLevel = "debug"



local currentDirection = 0

------------------------------------------------------------
-- Map of fatest way to turn to given direction from current
-- fastFace[current][wanted] = turn n
-- where n > 0 turnRight and n < 0 turnLeft
-- example
-- fastFace[2][0] = Right 2
-- fastFace[0][1] = Left 1
-- fastFace[1][1] = 0 - no turn
 -- calc = w-c-(QUOTIENT(w-c, 3)*4)
local fastFace = {{  0,  1,  2, -1 }, -- current 0
                  { -1,  0,  1,  2 }, -- current 1
                  { -2, -1,  0,  1 }, -- current 2
                  {  1, -2, -1,  0 }} -- current 3

local directionValues = { ["north"] = 0,
                          ["east"] = 1,
                          ["south"] = 2,
                          ["west"] = 3
                        }

local directionStrings = { [0] = "north",
                           [1] = "east",
                           [2] = "south",
                           [3] = "west"
                         }


local x,y,z = 0,0,0

local safe = false

function getDir()
    return currentDirection
end

function getPos()
    return { x, y, z}
end

function goTo(n)
  print(type(n))
  for a,i in pairs(n) do
  print(i,type(i))
  end
    l={{y,n[2],0,2},{x,n[1],1,3},{z,n[3],up,down}}
    for a,i in pairs(l) do
        if type(i[3])=="number" then
            if i[1]>i[2] then
                face(i[4])
  for j=1,i[1]-i[2] do
  if not dig() then
  up()
  end
  forward()
  end
            else
                face(i[3])
  for j=1,i[2]-i[1] do
  dig()
  forward()
  end
            end
        else
            if i[1]>i[2] then
                i[4](i[1]-i[2])
            else
                 i[3](i[2]-i[1])
            end
        end
    end
    face(0)
end

function move(x_,y_,z_)
    l={{y_,0,2},{x_,1,3},{z_,up,down}}
    for a,i in pairs(l) do
        if type(i[3])=="number" then
            if i[1]<0 then
                face(i[3])
            else
                face(i[2])
            end
            forward(i[1])
        else
            if i[1]>0 then
                i[4](z_)
            else
                i[3](z_)
            end
        end
    end
    face(0)
end

--
-- MOVEMENT FUNCTIONS
--
function updateCurrentPostionBy(n)
    if currentDirection == 0 then
        y=y+n
    elseif currentDirection == 1 then
        x=x+n
    elseif currentDirection == 2 then
        y=y-n
    else
        x=x-n
    end
    log.trace("Postion "..x..", "..y..", "..z)
end

function updateCurrentHeightBy(n)
  z = z + n
end

function forward(n)
    n = n or 1
    for i = 1, n do
      if turtle.forward() then
          updateCurrentPostionBy(1)
      else
          return false
      end
    end
    return true
end

function back(n)
  n = n or 1
  for i = 1, n do
    if turtle.back() then
        updateCurrentPostionBy(-1)
    else
        return false
    end
  end
  return true
end

function up(n)
  n = n or 1
  for i = 1, n do
    if turtle.up() then
        updateCurrentHeightBy(1)
    else
        return false
    end
  end
  return true
end

function down(n)
    n = n or 1
    for i = 1, n do
      if turtle.down() then
          updateCurrentHeightBy(-1)
      else
          return false
      end
    end
    return true
end


--
-- FORCED MOVEMENT FUNCTIONS
--
function forceForward()
    while not forward() do
      dig()
      turtle.attack()
    end
end

function forceBack()
    while not back() do
      face(currentDirection +2)
      dig()
      turtle.attack()
      face(currentDirection +2)
    end
end

function forceUp()
    while not up() do
      digUp()
      turtle.attackUp()
    end
end

function forceDown()
    while not down() do
      digDown()
      turtle.attackDown()
    end
end

--
-- TURNING FUNCTIONS
--
function updateCurrentDirectionBy(n)
    currentDirection = (currentDirection+n)%4
    log.trace("Facing "..directionStrings[currentDirection])
end

function left(n)
    n = n or 1
    for i=1,n do
        turtle.turnLeft()
    end
    updateCurrentDirectionBy(-n)
end

function right(n)
    n = n or 1
    for i=1,n do
        turtle.turnRight()
    end
    updateCurrentDirectionBy(n)
end

function face(wantedDirection)
    if type(wantedDirection) == "string" then
      wantedDirection = directionValues[wantedDirection]
    end
    wantedDirection = wantedDirection % 4

    log.trace("currentDirection="..currentDirection..", turning to "..wantedDirection)
    t = fastFace[currentDirection+1][wantedDirection+1]
    --print("fastFace="..t)
    if (t < 0) then
      left(t*-1)
    elseif (t > 0) then
      right(t)
    end
end

--
-- DIG FUNCTIONS
--
function dig(method)
  method = method or { fnDig = turtle.dig, fnDetect = turtle.detect }
  if type(method.fnDetect) ~= "function" then
    assert("Invalid methods passed to dig() function")
  end
  if method.fnDetect() then
    r = select(2, method.fnDig())
    if r == "Unbreakable block detected" then
      return false
    end
  end
  return true
end

function digDown()
  return dig({ fnDig = turtle.digDown, fnDetect = turtle.detectDown })
end

function digUp()
  return dig({ fnDig = turtle.digUp, fnDetect = turtle.detectUp })
end
