-- 3dprint
--

os.loadAPI("TurtleAPI")
t=TurtleAPI

-- block code used to fill foundation if requested
local BLOCK_FOUNDATION = 99
local FOUNDATION_NONE = 0
local FOUNDATION_NON_AIR = 1
local FOUNDATION_FULL = 2


local hugContour = true
local fillFoundation = FOUNDATION_NON_AIR

local startDirection = 0 -- Used to offset from initial

local blueprint = {}

blueprint.legend   = {
                    ["1"] = "minecraft:cobblestone",
                    ["2"] = "minecraft:planks",
                    ["3"] = "minecraft:torch",
                    ["99"] = "minecraft:cobblestone"  -- foundation
                 }

blueprint.pattern  = {
                  {{ 0, 0, 0, 3, 0, 0, 0, 0, 3 },
                   { 0, 0, 0, 1, 0, 0, 0, 0, 1 },
                   { 0, 0, 0, 1, 2, 2, 2, 2, 1 },
                   { 0, 0, 0, 0, 1, 1, 1, 1, 0 },
                   { 0, 0, 0, 0, 1, 3, 0, 1, 0 },
                   { 0, 0, 0, 0, 1, 0, 0, 1, 0 }}, -- ground

                  {{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                   { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                   { 0, 0, 0, 1, 2, 2, 2, 2, 1 },
                   { 0, 0, 0, 0, 1, 1, 1, 1, 0 },
                   { 0, 0, 0, 0, 1, 0, 0, 1, 0 },
                   { 0, 0, 0, 0, 1, 0, 0, 1, 0 }}, -- ground

                  {{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                   { 0, 0, 0, 1, 0, 0, 0, 0, 1 },
                   { 0, 0, 0, 1, 2, 2, 2, 2, 1 },
                   { 0, 0, 0, 0, 1, 1, 1, 1, 0 },
                   { 0, 0, 0, 0, 1, 0, 0, 1, 0 },
                   { 0, 0, 0, 0, 1, 0, 0, 1, 0 }}, -- ground

                   {{ 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 0, 0, 0, 1, 2, 2, 2, 2, 1 },
                    { 0, 0, 0, 0, 1, 1, 1, 1, 0 },
                    { 0, 0, 0, 0, 1, 0, 0, 1, 0 },
                    { 0, 0, 0, 0, 1, 0, 0, 1, 0 }}, -- ground
                  }


-- Maps a block to an inventory slot
local blockMap = {}

--
-- Prints a horizontal blueprint.pattern made of slices n times
--
function extrude(repeats)

  startDirection = t.getDir() -- Used to offset from initial

  mapBlocks()
  for n=1,repeats do
      print("Extrude "..n.." of "..repeats)

      local depth = table.getn(blueprint.pattern)
      for d = 1, depth do
        print("Building slice "..d.." of "..depth)

        relativeFace(1) -- right

        buildFoundation(blueprint, d, fillFoundation)

        -- Reverse direction
        relativeAboutFace() -- face opposite



        local height = table.getn(blueprint.pattern[d])
        local width = table.getn(blueprint.pattern[d][1])
        for hpos = 1, height do
          local h = height - hpos + 1 -- reverse height direction

          -- build layer
          forceUp()

          local mustBuildLayer = false

          for w = 1, width do
            if getPatternBlockIndex(blueprint, d, h, w) ~= 0 then
              mustBuildLayer = true
            end
          end

          if mustBuildLayer then
            for w = 1, width do

              local blockIndex = getPatternBlockIndex(blueprint, d, h, w)

              if blockIndex ~= 0 then
                selectBlock(blockIndex)
                turtle.placeDown()
              end

              if w < width then
                forceForward()
              end
            end

            -- Reverse direction
            relativeAboutFace() -- face opposite
          end
        end

        -- At wrong end
        if getRelativeDirection() == 3 then
          relativeFace(3) -- face left
          for w = 1, width -1 do
            forceForward()
          end
        end

        relativeFace(2) -- face south
        forceForward()

        -- Back down to ground
        for h = 1, height do
          -- dig down to
          if h < height then
            forceDown()
          else
            if hugContour then
              if not turtle.down() then -- if not possible stay up 1
                  -- check for leaves
                  if detectDown("leaves") then
                  end
              end
            else
              forceDown() -- forceDown to original start
            end
          end
        end

        -- Go down 1 further if still nothing below
        if hugContour then
          turtle.down()
        end

        -- Throw away any item not required
        cleanHouse(pattern)

      end

  end

  relativeFace(0) -- face forward again
  print("Extrusion complete")

end

function forceForward()
    while not turtle.forward() do
      turtle.dig()
      turtle.attack()
    end
end

function forceUp()
    while not turtle.up() do
      turtle.digUp()
      turtle.attackUp()
    end
end

function forceDown()
    while not turtle.down() do
      turtle.digDown()
      turtle.attackDown()
    end
end

--
-- Get/Set direction relative to turtles initial startDirection
--
function getRelativeDirection()
  return (t.getDir() - startDirection) % 4
end

function relativeFace(n)
  assert(n ~= nil, "relativeFace requires a number")
  return t.face(startDirection + n)
end

function relativeAboutFace()
  relativeFace(getRelativeDirection() + 2)
end


--
-- Get the current block type from blueprint.pattern
--
function getPatternBlockIndex(blueprint, d, h, w)
  if getRelativeDirection() == 1 then
    return blueprint.pattern[d][h][w]
  else
    local width = table.getn(blueprint.pattern[d][h])
    return blueprint.pattern[d][h][width - w + 1]
  end
end

--
-- Fill any holes underneath the structure we are building
--
function buildFoundation(blueprint, d, fillFoundation)

  local h = table.getn(blueprint.pattern[d])
  local width = table.getn(blueprint.pattern[d][h])

  -- build foundation if required
  for w = 1, width do

    if fillFoundation ~= FOUNDATION_NONE then

      local blockIndex = 0
      if fillFoundation == FOUNDATION_NON_AIR then
        blockIndex = getPatternBlockIndex(blueprint, d, h, w)
      else
        blockIndex = BLOCK_FOUNDATION
      end

      if blockIndex ~= 0 then

        local fillHeight = 0
        while turtle.down() do
          fillHeight = fillHeight + 1
        end

        for i = 1,fillHeight do
          selectBlock(BLOCK_FOUNDATION)
          turtle.up()
          turtle.placeDown()
        end
      end
    end

    if w < width then
      forceForward()
    end
  end

end


--
-- Finds the ingredients in the inventory area
-- and create a map to its location
--
function mapBlocks()
    print("Blocks required for pattern : ")
  for i,v in pairs(blueprint.legend) do
    local blockName = v or "nil"
    assert(blockName ~= "nil", "Missing blockname for blockIndex="..i)

    print(" - "..blockName)
    local inventoryPos = locateBlockInInventory(blockName)
    blockMap[i] = inventoryPos
  end

end

--
-- Finds the requested block in turtle invetory
--
function locateBlockInInventory(blockName)

  --print("Searching for "..blockName)
  while 1 do
    for s = 1,16 do
      turtle.select(s)
      local item = turtle.getItemDetail()
      if item ~= nil then
        --print("box "..s.." contains "..item.name)
        if item.name == blockName then
          --print("box "..s.." contains "..item.name)
          return s
        end
      else
        --print("box "..s.." is empty")
      end
    end

    print("Please add "..blockName.." items to turtle")
    print("Press enter to coninue ..")
    io.read()
  end
end

--
--
--
function selectBlock(legendBlock)

  legendBlock = tostring(legendBlock)
  local inventoryPos = blockMap[legendBlock]
  print("blockIndex="..legendBlock.." maps to inventoryPos=" ..inventoryPos)
  turtle.select(inventoryPos)
  if turtle.getItemCount() == 0 then
      inventoryPos = locateBlockInInventory(blueprint.legend[legendBlock])
      blockMap[legendBlock] = inventoryPos
  end

  return inventoryPos
end

function cleanHouse(pattern)

  for s = 1,16 do
      turtle.select(s)
      local item = turtle.getItemDetail()
      if item ~= nil then
          local wanted = false
          for i,v in pairs(blueprint.legend) do
            local legendBlock = v or "nil"
            --print("box "..s.." contains "..item.name)
            if item.name == legendBlock then
                wanted = true
            end
          end
          if not wanted then
              turtle.drop()
          end
      end
  end
end


-------------------------------------------------
-- MAIN

extrude(10)
